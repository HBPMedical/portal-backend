{
  "name": "jasmine-cucumber",
  "version": "1.1.0",
  "description": "cucumer-like javascript api for jasmine",
  "main": "src/jasmine-cucumber.js",
  "scripts": {
    "test": "karma start --single-run=true"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/DealerDotCom/jasmine-cucumber.git"
  },
  "keywords": [
    "jasmine",
    "cucumber",
    "test",
    "integration",
    "bdd"
  ],
  "author": {
    "name": "Jonathan Hoguet",
    "email": "jonathan.hoguet@dealer.com"
  },
  "license": "Apache-v2",
  "bugs": {
    "url": "https://github.com/DealerDotCom/jasmine-cucumber/issues"
  },
  "devDependencies": {
    "phantomjs": "~1.9.11",
    "karma-phantomjs-launcher": "~0.1.3",
    "karma": "~0.12.0",
    "karma-jasmine": "~0.2.0"
  },
  "readme": "jasmine-cucumber\n================\n\n[Getting Started with Karma](https://github.com/DealerDotCom/karma-jasmine-cucumber)\n\n[Getting Started with Protractor](https://github.com/DealerDotCom/protractor-jasmine-cucumber)\n\n\n# Motivation\nThe motivation behind this project was to bring the power of cucumber to expressing complex permutations of tests where jasmine alone starts to fail. This isn't to say that you should no longer use jasmine syntax in favor of this syntax, instead you should leverage this when your jasmine tests start getting too complex and you find yourself copying and / or moving lots of code around. \n\nPersonally, I have found that after about 50 tests jasmine starts to go down hill. You can refactor your tests to reduce the duplication but then the tests become high maintenance and still tend to be brittle. Cucumber provides a nice syntax for managing this level of complexity by making it easy to re-use a step definition in an almost infinite number of combinations, with the only duplication being human readable scenarios. \n\nIn short, unit tests likely still make sense in Jasmine and would be hard to write in a GWT style. Integration tests (integrating multiple units) is where this will shine. \n\n*What about cucumberjs?* I haven't spent a lot of effort trying to make cucumberjs work - but it has the extra layer of translating non js files into js which adds complexity (it isn't **just** javascript). Personally I have not found this added complexity to be worth it. It was also very important to me that 1 step be able to abstract away other steps (see nested steps below). Which is difficult/ discouraged in the cucumber implementations I have used. \n\n#API\nI recommend splitting your files into specs and steps, here is an example specs.js file\n\n```javascript\n\tfeature('Calculator: add')\n\t    .scenario('should be able to add 2 numbers together')\n    \t    .when('I enter \"1\"')\n        \t.and('I add \"2\"')\n\t        .then('I should get \"3\"')\n    \t.scenario('should be able to add to a result of a previous addition')\n        \t.given('I added \"1\" and \"2\"')\n\t        .when('I add \"3\"')\n    \t    .then('I should get \"6\"')\n```\n    \t    \nand steps.js file\n\t\n```javascript\n\tfeatureSteps('Calculator:')\n\t    .before(function(){\n    \t    this.values = [];\n        \tthis.total = null;\n\t    })\n    \t.given('I added \"(.*)\" and \"(.*)\"', function(first, second){\n        \tthis.when('I enter \"' + first + '\"');\n\t        this.when('I add \"' + second + '\"');\n    \t})\n\t    .when('I enter \"(.*)\"', function(val){\n    \t    this.values.push(val * 1);\n\t    })\n    \t.when('I add \"(.*)\"', function(val){\n        \tthis.values.push(val * 1);\n\t        this.total = this.values[0] + this.values[1];\n    \t    this.values = [this.total];\n\t    })\n    \t.then('I should get \"(.*)\"', function(val){\n        \texpect(this.total).toBe(val * 1);\n\t    })\n```\n\nSo what are we doing?\n\n```javascript\n\tfeature('Calculator: add')\n```\n\nCreates a feature to run tests and serves 2 functions. \n1) the string is used in output for a failing test\n2) when declaring step definition, we use regex against the feature string\n\n```javascript\n\t.scenario('should be able to add 2 numbers together')\n```\n\nCreates a scenario, which really just provides output during a failing test\n\n```javascript\n\t.when('I enter \"1\"')\n```\n\nTells jasmine-cucumber to execute the step definition that matches `'I enter \"1\"'`\n\n```javascript\n\t.and('I add \"2\"')\n```\n\nIs the same as `when('I add \"2\"')`. \n\n*Note:* Given and When are interchangable, thens are special because they are wrapped in a jasmine `it()`. In v2.0 they likely will all be interchangeable. \n\nEnough about the specs, lets take a look at the steps. \n\n```javascript\n\tfeatureSteps('Calculator:')\n```\n\nis using regex to say match all features with `Calculator:`\n\n```javascript\n\t    .before(function(){\n    \t    this.values = [];\n        \tthis.total = null;\n\t    })\n```\n\t   \nprovides code to run before each assertion, this maps to a jasmine `beforeEach`. `this` is a `scenarioContext` which is reset on every assertion (`then`) and allows us to share state between step definitions\n\n```javascript\n\t    .when('I enter \"(.*)\"', function(val){\n    \t    this.values.push(val * 1);\n\t    })\n```\n\t    \nmatches `I enter \"1\"` making val = `'1'` \n\t \n```javascript\n    \t.when('I add \"(.*)\"', function(val){\n        \tthis.values.push(val * 1);\n\t        this.total = this.values[0] + this.values[1];\n    \t    this.values = [this.total];\n\t    })\n```\n\t    \nmatches `I add \"2\"` \n\t    \n```javascript\n    \t.then('I should get \"(.*)\"', function(val){\n        \texpect(this.total).toBe(val * 1);\n\t    })\n```\n\nmatches `I should get \"3\"` and does the assertion which is being wrapped in a jasmine `it()`\n\t    \n```javascript\n  \t.given('I added \"(.*)\" and \"(.*)\"', function(first, second){\n        \tthis.when('I enter \"' + first + '\"');\n\t        this.when('I add \"' + second + '\"');\n    \t})\n```\n\nAsync is also supported with an api inspired by Grunt. \n\n```javascript\n    \t.when('I add \"(.*)\"', function(val){\n        \tvar done = this.async(),\n        \t    scenarioContext = this;\n        \tsetTimeout(function(){\n        \t\tscenarioContext.values.push(val * 1);\n\t        \tscenarioContext.total = scenarioContext.values[0] + scenarioContext.values[1];\n    \t    \tscenarioContext.values = [scenarioContext.total];\n        \t\tdone();\n        \t});\n\t    })\n```\nThe next step won't be called until the done function is executed. In effect, done calls the next step. \n    \t\nThis step definition is especially cool as it allows us to abstract away other step definitions. This allows the more complex scenario to be more readable with one line instead of 2 (imagine 4 or 5 lines of setup for each scenario in a real world app). It then re-uses the existing steps by simply creating the strings that would match their regex. \n\nLast thing worth mentioning is the output… \n\nIf you enter a string that doesn't match any regex, the scenario will fail stating that it is missing a step definition: \n\n\tFeature: Calculator: add\n    Scenario: should be able to add to a result of a previous addition\n     Given  I added \"1\" and \"2\"\n     When  I add \"3\"\n\n    Missing step definitions FAILED\n      Missing step definitions:\n        I get \"6\"\n        \nSo now we know we need a step definition for 'I get \"6\"', or do we… it also attempts to find steps that are a close match and will provide a hint in case it already exists… \n\n    Feature: Calculator: add\n    Scenario: should be able to add to a result of a previous addition\n     Given  I added \"1\" and \"2\"\n     When  I add \"3\"\n\n    Missing step definitions FAILED\n      Missing step definitions:\n        I get \"6\"\n          Did you mean?\n            I should get \"3\" (8)\n            \nIt is using levenshteinDistance which is very rough, but often its just enough to remind you that you're off by one word or letter.\n\n## Want More… \nUnlike traditional cucumber, you can pass plain javascript objects into your gherkin statements. \n\n```javascript\n\t.given('a person', { name : 'Lance', age : 3 })\n```\n\nWhich is passed to your step definition\n\n```javascript\n\t.given('a person', function(person){\n    \tthis.person = person;\n  \t})\n```\nYou can pass any object, even an array\n\n```javascript\n\t.given('people', [\n      { name : 'Lance', age : 3 },\n      { name : 'Lana', age : 2 }\n    ])\n```\n\nIn my experience this has been most useful when passing in many properties through regex gets overly verbose, eg: \n\n```javascript\n\t.given('a person named \"Lance\"')\n\t.given('that person is \"3\" years old')\n\t.given('that person has \"2\" siblings')\n```\n\nRepeat this for 4 or 5 scenarios and you will really appreciate \n\n```javascript\n\t.given('a person', { name : 'Lance', age : 3, siblings : 2 })\n\t\n```\n\nSpecial thanks to gregorylimoratto for a pull request to improve the output of failed tests to include these arguments\n\nGotchas\n===\n\nBe careful not to use 'this' inside the inject function, as it will be a different context than your scenario. In this example, we are caching the scenario context at the top level, then using it to grab an $injector.\n\n```javascript\n.before(function(){\n    var scenarioContext = this;\n\n    module('i18n');\n    inject(function(_$injector_){\n         scenarioContext.$injector = _$injector_;\n    });\n        \n    ...\n})\n```\n# Example\nAs said previously, jasmine-cucumber won't make sense for every test you have. Where it excels is when the **intent** is getting *lost* in the complexity of the tests themselves. How will a new user (or you in a few months) know what the intent is of the test that is failing, or where to inject your new scneario or regression? With cucumber, this is easy, the intent is human readable and separated from the implementation. The architecture to manage the complexity is a series of step definitions. There isn't a lot to ramp up to. \n\nTake these 2 examples\n\n## Before\n```javascript\ndescribe('i18n interpolation specs', function(){\n    // NOTE: we are testing with $compile instead of $interpolate b/c $compile is upstream and gives us more confidence\n    //  that we can interpolate attributes and other scenarios abstracted away from $interpolate\n    var $compile,\n        scope,\n        getWatchCount,\n        $interpolate;\n\n    beforeEach(function(){\n        module('i18n');\n        inject(function(i18nMessageResolver, i18nMessages, _$compile_, $rootScope, _$interpolate_){\n            $compile = _$compile_;\n            scope = $rootScope.$new(true);\n            scope.name = 'Lance';\n            $interpolate = _$interpolate_;\n\n            angular.extend(i18nMessages, {\n                'greeting.label' : 'Hi',\n                'greeting.dynamicLabel' : 'Hi {0}, so glad to see you again!',\n                'greeting.moreDynamicLabel' : 'Hi {0}, you\\'re {1} years old today!',\n                'greeting.multiDynamicLabel' : 'Hi {0}, you are {0}, right?',\n                'simple.choice' : '{0} {0,choice,0#cars|1#car|1<cars}',\n                'decimal.choice' : '{0,choice,0#none|.5#half|1#one|1.5#one and a half|1.5<lots}',\n                'negative.choice' : '{0,choice,-1#negative|0#zero|1#one|1<lots}',\n                'dynamic.choice' : '{0,choice,0#no leads|1#1 lead|2#{0} leads}'\n            });\n            getWatchCount = function(){\n                return $rootScope.$$watchers + scope.$$watchers;\n            };\n\n        });\n    });\n\n    // a series of scenarios\n    // left side should be wrapped in any element - (easier to test by calling element.html() so we need any element)\n    // right side should be the expected .html() of that element\n    var expectations = {\n        // nothing to interpolate\n        \"<p>Hi</p>\" : \"Hi\",\n\n          // a simple label\n        \"<p>{{@i18n(greeting.label)}}</p>\" : \"Hi\",\n\n        // two simple labels\n        \"<p>{{@i18n(greeting.label)}} {{@i18n(greeting.label)}}</p>\" : \"Hi Hi\"\n    };\n\n    var expectationsWithWatch = {\n        // interpolate without i18n\n        \"<p>{{name}}</p>\" : \"Lance\",\n\n        // a label that is partially dynamic\n        \"<p>{{@i18n(greeting.dynamicLabel)('Lance')}}</p>\" : \"Hi Lance, so glad to see you again!\",\n\n        // a label that is more dynamic\n        \"<p>{{@i18n(greeting.moreDynamicLabel)('Lance', 3)}}</p>\" : \"Hi Lance, you're 3 years old today!\",\n\n        // a label with multiple instances of a variable\n        \"<p>{{@i18n(greeting.multiDynamicLabel)('Lance')}}</p>\" : \"Hi Lance, you are Lance, right?\",\n\n        // a label with choice format (zero)\n        \"<p>{{@i18n(simple.choice)(0)}}</p>\" : \"0 cars\",\n\n        // a label with choice format (1)\n        \"<p>{{@i18n(simple.choice)(1)}}</p>\" : \"1 car\",\n\n        // a label with choice format (2)\n        \"<p>{{@i18n(simple.choice)(2)}}</p>\" : \"2 cars\",\n\n        // a label with choice format negative\n        \"<p>{{@i18n(negative.choice)(1)}}</p>\" : \"one\",\n        \"<p>{{@i18n(negative.choice)(-1)}}</p>\" : \"negative\",\n\n        // a label with choice format decimal (.5)\n        \"<p>{{@i18n(decimal.choice)(.5)}}</p>\" : \"half\",\n\n        // a label with choice format decimal (1.5)\n        \"<p>{{@i18n(decimal.choice)(1.5)}}</p>\" : \"one and a half\",\n\n        // a label with choice format decimal (>1.5)\n        \"<p>{{@i18n(decimal.choice)(1.6)}}</p>\" : \"lots\",\n\n        // dynamic.choice\n        \"<p>{{@i18n(dynamic.choice)(0)}}</p>\" : \"no leads\",\n        \"<p>{{@i18n(dynamic.choice)(1)}}</p>\" : \"1 lead\",\n        \"<p>{{@i18n(dynamic.choice)(2)}}</p>\" : \"2 leads\"\n    };\n\n    Object.keys(expectations)\n    .map(function(key){\n        return {\n            input : key,\n            expected : expectations[key],\n            expectedWatches : 0\n        };\n    })\n    .concat(Object.keys(expectationsWithWatch).map(function(key){\n        return {\n            input : key,\n            expected : expectationsWithWatch[key],\n            expectedWatches : 1\n        };\n    }))\n    .forEach(function(test){\n        it('should interpolate ' + test.input + ' to ' + test.expected, function(){\n\n            var el;\n            runs(function(){\n                el = $compile(test.input)(scope);\n                scope.$digest();\n            });\n            var nextThreadLoop = false;\n            setTimeout(function(){\n                nextThreadLoop = true;\n            })\n            waitsFor(function(){\n                return nextThreadLoop;\n            });\n\n            runs(function(){\n                expect(el.html()).toBe(test.expected);\n                expect((scope.$$watchers || []).length).toBe(test.expectedWatches);\n            });\n        });\n    });\n\n    it('should be able to do dynamic interpolation', function(){\n        var dynamic = 'greeting.label';\n        var output = $interpolate('{{@i18n(' + dynamic + ')}}')();\n        expect(output).toBe('Hi');\n    });\n});\n\n````\n## After\n\n```javascript\n/* globals feature:false, featureSteps:false, expect:false, runs:false, waitsFor:false */\nfeature('i18n: shouldn\\'t break interpolation')\n    .scenario('should still be able to interpolate nothing')\n        .when('I compile \"<p>Hi</p>\"')\n        .then('I should get html \"Hi\"')\n        .and('there should be \"0\" watches')\n    .scenario('should still be able to interpolate variable')\n        .given('I set scope \"name\" to \"Lance\"')\n        .when('I compile \"<p>{{name}}</p>\"')\n        .then('I should get html \"Lance\"')\n        .and('there should be \"1\" watch')\n\nfeature('i18n: labels')\n    .scenario('should be able to translate a simple label')\n        .given('I set message \"greeting.label\" to \"Hi\"')\n        .when('I compile \"<p>{{@i18n(greeting.label)}}</p>\"')\n        .then('I should get html \"Hi\"')\n        .and('there should be \"0\" watch')\n\n    .scenario('should be able to translate multiple labels')\n        .given('I set message \"greeting.label\" to \"Hi\"')\n        .when('I compile \"<p>{{@i18n(greeting.label)}} {{@i18n(greeting.label)}}</p>\"')\n        .then('I should get html \"Hi Hi\"')\n        .and('there should be \"0\" watch')\n\nfeature('i18n: labels with place holders')\n    .scenario('should be able to inject a value into a label')\n        .given('I set message \"greeting.label\" to \"Hi {0}\"')\n        .and('I set scope \"name\" to \"Lance\"')\n        .when('I compile \"<p>{{@i18n(greeting.label)(name)}}</p>\"')\n        .then('I should get html \"Hi Lance\"')\n        .and('there should be \"1\" watch')\n    .scenario('should be able to inject multiple values into a label')\n        .given('I set message \"greeting.label\" to \"Hi {0}, you are {1} today\"')\n        .and('I set scope \"name\" to \"Lance\"')\n        .and('I set scope \"age\" to \"3\"')\n        .when('I compile \"<p>{{@i18n(greeting.label)(name, age)}}</p>\"')\n        .then('I should get html \"Hi Lance, you are 3 today\"')\n        .and('there should be \"1\" watch')\n    .scenario('should be able to inject the same value more than once')\n        .given('I set message \"greeting.label\" to \"Hi {0}, you are {0}, right?\"')\n        .and('I set scope \"name\" to \"Lance\"')\n        .when('I compile \"<p>{{@i18n(greeting.label)(name, age)}}</p>\"')\n        .then('I should get html \"Hi Lance, you are Lance, right?\"')\n        .and('there should be \"1\" watch')\n\nfeature('i18n: choice format')\n    .scenario('should be get the first choice when providing a value less than the first one')\n        .given('I set message \"cars\" to \"{0,choice,0#none|1#a car|1<cars}\"')\n        .when('I compile \"<p>{{@i18n(cars)(-1)}}</p>\"')\n        .then('I should get html \"none\"')\n        .and('there should be \"1\" watch')\n    .scenario('should be get the first choice when providing a equal to the first one')\n        .given('I set message \"cars\" to \"{0,choice,0#none|1#a car|1<cars}\"')\n        .when('I compile \"<p>{{@i18n(cars)(0)}}</p>\"')\n        .then('I should get html \"none\"')\n        .and('there should be \"1\" watch')\n    .scenario('should be get the first choice when providing a value greater than the first one but less than the second one')\n        .given('I set message \"cars\" to \"{0,choice,0#none|1#a car|1<cars}\"')\n        .when('I compile \"<p>{{@i18n(cars)(0.5)}}</p>\"')\n        .then('I should get html \"none\"')\n        .and('there should be \"1\" watch')\n    ...\n    \n    /* globals featureSteps:false, module:false, inject:false, expect:false, waitsFor:false, runs:false, spyOn:false */\n\nfeatureSteps(\"i18n:\")\n    .before(function(){\n        var scenarioContext = this;\n\n        module('i18n');\n        inject(function(_$injector_){\n            scenarioContext.$injector = _$injector_;\n        });\n        var $rootScope = this.$injector.get('$rootScope');\n        this.scope = $rootScope.$new(true);\n        this.getWatchCount = function(){\n            return ($rootScope.$$watchers || []).length + (this.scope.$$watchers || []).length;\n        };\n        spyOn(this.$injector.get('$log'), 'error');\n\n    })\n    .given('I set scope \"(.*)\" to \"(.*)\"', function(prop, val){\n        this.scope[prop] = val;\n    })\n    .given('I set message \"(.*)\" to \"(.*)\"', function(code, val){\n        this.$injector.get('i18nMessages')[code] = val;\n    })\n    .when('I compile \"(.*)\"', function(fragment){\n        var scenarioContext = this;\n        this.scope.$apply(function(){\n            scenarioContext.element = scenarioContext.$injector.get('$compile')(fragment)(scenarioContext.scope);\n        });\n    })\n    .then('I should get html \"(.*)\"', function(html){\n        expect(this.element.html()).toBe(html);\n    })\n    .then('there should be \"(.*)\" watche?s?', function(watchCount){\n        var scenarioContext = this,\n            nextThreadLoop = false;\n        setTimeout(function(){\n            nextThreadLoop = true;\n        })\n        waitsFor(function(){\n            return nextThreadLoop;\n        });\n\n        runs(function(){\n            expect(scenarioContext.getWatchCount()).toBe(watchCount * 1);\n        });\n    })\n    .then('there should be \"(.*)\" errors? logged', function(errorCount){\n        expect(this.$injector.get('$log').error.callCount).toBe(errorCount * 1);\n    });\n\n```\n\nWhich has a clearer intent? Which is easier to jump into as a new user? *NOTE:* that I started doing this in traditional jasmine and switched to cucumber when I felt like the intent was getting lost and/or the comlexity warranted it (in this case it was mostly about intent). \n\n# Release Notes\n## v 1.1.0\n* added support for arguments passed into gherkin expressions - like cucumber DataTables but better :)\n* thanks to gregorylimoratto for the pull request to improve the error handling and expose this hidden feature\n\n## v 1.0.3\n* fixed bug where synchronous tests using async function would cause bad state\n* fixed bug where missing step wouldn't cause scenario to fail if previous step was async\n\n## v 1.0.2\n* fixed bug causing the last step to be skipped\n\n## v 1.0.0\n* Added support for Jasmine 2.0 syntax. Breaking change, use v.0.2.0 for Jasmine 1.3 syntax. This is primarily to add support for async. \n\n## v 0.2.0\nSupports Jasmine 1.3\n# Roadmap\n* look closer at cucumber.js\n\n\t\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/DealerDotCom/jasmine-cucumber",
  "_id": "jasmine-cucumber@1.1.0",
  "_from": "jasmine-cucumber@~1.1.0"
}
